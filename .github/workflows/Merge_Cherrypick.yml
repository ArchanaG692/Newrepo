name: cherry-pick-only-merge

on:
  workflow_run:
    workflows: ["code-scan"]
    types: [completed]

permissions:
  contents: write
  pull-requests: write

jobs:
  cherry_pick_selected_commits:
    if: github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest

    steps:
      - name: V2 PROOF – new workflow running
        run: |
          echo "✅ Using PR body commit selection + automatic conflicted-file CP marker resolution"
          echo "workflow_run id = ${{ github.event.workflow_run.id }}"
          echo "workflow_run head_sha = ${{ github.event.workflow_run.head_sha }}"

      - name: Set variables
        run: |
          echo "RUN_ID=${{ github.event.workflow_run.id }}" >> $GITHUB_ENV
          echo "TEMP_BRANCH=cp-${{ github.event.workflow_run.id }}-${{ github.event.workflow_run.head_sha }}" >> $GITHUB_ENV

      # ------------------------------------------------------------
      # 1) Identify PR + extract commit list from PR body
      # ------------------------------------------------------------
      - name: Get PR number + commit list from PR body
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          RUN_ID: ${{ github.event.workflow_run.id }}
        run: |
          set -euo pipefail

          PR_NUMBER=$(gh api "repos/$REPO/actions/runs/$RUN_ID" --jq '.pull_requests[0].number')
          if [ -z "$PR_NUMBER" ] || [ "$PR_NUMBER" = "null" ]; then
            echo "ERROR: No PR associated with this workflow_run."
            exit 1
          fi

          echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_ENV
          echo "PR number: $PR_NUMBER"

          BODY=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json body --jq '.body // ""')

          echo "----- PR BODY START -----"
          echo "$BODY"
          echo "----- PR BODY END -----"

          COMMITS=$(python3 -c '
          import sys, re
          text = sys.stdin.read().replace("\r\n","\n")
          lines = text.splitlines()
          
          key_re = re.compile(r"^\s*CHERRY[\s_]+PICK[\s_]+COMMITS\s*:\s*(.*)$", re.IGNORECASE)
          sha_re = re.compile(r"\b[0-9a-f]{7,40}\b")
          
          commits=[]
          for i,l in enumerate(lines):
              m=key_re.match(l)
              if not m:
                  continue
              commits += sha_re.findall(m.group(1) or "")
              j=i+1
              while j < len(lines) and lines[j].strip():
                  commits += sha_re.findall(lines[j])
                  j += 1
              break
          
          print(" ".join(commits))
          ' <<< "$BODY")

          if [ -z "$COMMITS" ]; then
            echo "ERROR: No commits found in PR body."
            echo "Use:"
            echo "CHERRY PICK COMMITS:"
            echo "7233de3"
            exit 1
          fi

          echo "COMMITS=$COMMITS" >> $GITHUB_ENV
          echo "Selected commits: $COMMITS"

      # ------------------------------------------------------------
      # 2) Checkout INT1
      # ------------------------------------------------------------
      - name: Checkout INT1
        uses: actions/checkout@v4
        with:
          ref: INT1
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Fetch all refs
        run: |
          git fetch origin --prune --no-tags \
            +refs/heads/*:refs/remotes/origin/* \
            +refs/pull/*/head:refs/remotes/origin/pull/*

      - name: Create temp branch from INT1
        run: |
          git checkout -b "$TEMP_BRANCH" "origin/INT1"

      # ------------------------------------------------------------
      # 3) Cherry-pick with automatic conflicted-file CP marker resolution
      #    - On conflict: keep INT1 everywhere except within // CP_START..// CP_END blocks
      #    - Handles "empty cherry-pick" by skipping
      # ------------------------------------------------------------
      - name: Cherry-pick selected commits (auto conflicted-file CP marker strategy)
        run: |
          set -euo pipefail

          apply_cp_blocks_to_conflicts () {
            local sha="$1"
            echo "Applying CP blocks from SOURCE commit $sha to conflicted files only..."

            local conflict_files
            conflict_files=$(git diff --name-only --diff-filter=U || true)

            if [ -z "$conflict_files" ]; then
              echo "No conflicted files detected (unexpected)."
              return 0
            fi

            mkdir -p /tmp/srcfiles

            for f in $conflict_files; do
              echo "Resolving conflicted file: $f"

              # TARGET version from INT1
              if ! git show "origin/INT1:$f" > "/tmp/target_$(basename "$f")" 2>/dev/null; then
                echo "WARN: File $f not found on origin/INT1. Skipping CP strategy for this file."
                continue
              fi

              # SOURCE version from commit sha
              if ! git show "$sha:$f" > "/tmp/srcfiles/$(basename "$f")" 2>/dev/null; then
                echo "WARN: File $f not found in commit $sha. Using TARGET entirely."
                cp "/tmp/target_$(basename "$f")" "$f"
                continue
              fi

              python3 -c '
          import re, sys, pathlib
          
          work_path = pathlib.Path(sys.argv[1])
          target_path = pathlib.Path(sys.argv[2])
          source_path = pathlib.Path(sys.argv[3])
          
          target = target_path.read_text(encoding="utf-8", errors="replace")
          source = source_path.read_text(encoding="utf-8", errors="replace")
          
          pat = re.compile(r"(//\s*CP_START[\s\S]*?//\s*CP_END)", re.DOTALL)
          
          t_blocks = pat.findall(target)
          s_blocks = pat.findall(source)
          
          # If markers missing or mismatch -> use TARGET entirely
          if not t_blocks or not s_blocks or len(t_blocks) != len(s_blocks):
              work_path.write_text(target, encoding="utf-8")
              print(f"WARN: CP blocks missing/mismatch in {work_path}. Using TARGET (INT1) file entirely.")
              raise SystemExit(0)
          
          new_target = target
          for old, new in zip(t_blocks, s_blocks):
              new_target = new_target.replace(old, new, 1)
          
          work_path.write_text(new_target, encoding="utf-8")
          print(f"Resolved {work_path}: SOURCE wins only inside CP blocks; TARGET elsewhere.")
          ' "$f" "/tmp/target_$(basename "$f")" "/tmp/srcfiles/$(basename "$f")"
            done

            git add $conflict_files

            # If conflicts still remain, fail clearly
            if git diff --name-only --diff-filter=U | grep -q .; then
              echo "ERROR: Some conflicts remain after CP strategy:"
              git diff --name-only --diff-filter=U
              exit 1
            fi

            # ✅ IMPORTANT: finish cherry-pick correctly
            # If no staged changes, cherry-pick becomes empty -> skip it
            if git diff --cached --quiet; then
              echo "Cherry-pick became empty after resolution -> skipping commit $sha"
              git cherry-pick --skip
            else
              echo "Continuing cherry-pick after resolution for $sha"
              git cherry-pick --continue
            fi
          }

          for sha in $COMMITS; do
            echo "===== Processing commit: $sha ====="
            if git cherry-pick "$sha"; then
              echo "Cherry-pick succeeded for $sha"
            else
              echo "Cherry-pick conflict for $sha -> auto resolving conflicted files with CP markers"
              apply_cp_blocks_to_conflicts "$sha"
            fi
          done

      - name: Push temp branch
        run: |
          git push origin "$TEMP_BRANCH" --force

      # ------------------------------------------------------------
      # 4) Create PR + auto merge
      # ------------------------------------------------------------
      - name: Create PR from temp branch to INT1
        id: cpr
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const head = process.env.TEMP_BRANCH;
            const base = "INT1";

            const existing = await github.rest.pulls.list({
              owner, repo, state: "open", head: `${owner}:${head}`, base
            });

            if (existing.data.length) {
              core.info(`PR already exists: #${existing.data[0].number}`);
              core.setOutput("pr_number", existing.data[0].number);
              core.setOutput("pr_node_id", existing.data[0].node_id);
              return;
            }

            const commits = (process.env.COMMITS || "").split(" ").filter(Boolean);

            const pr = await github.rest.pulls.create({
              owner,
              repo,
              head,
              base,
              title: "Cherry-pick selected commits into INT1",
              body: [
                `Automated cherry-pick from PR #${process.env.PR_NUMBER}`,
                "",
                "Commits:",
                ...commits.map(c => `- \`${c}\``),
                "",
                "Conflict strategy (only when conflicts occur):",
                "- Uses INT1 version everywhere",
                "- Except inside // CP_START..// CP_END blocks where SOURCE commit wins",
              ].join("\n")
            });

            core.setOutput("pr_number", pr.data.number);
            core.setOutput("pr_node_id", pr.data.node_id);

      - name: Merge PR (SHA locked)
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = Number("${{ steps.cpr.outputs.pr_number }}");

            const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const expectedHead = pr.data.head.sha;

            await github.graphql(`
              mutation($prId: ID!, $expected: GitObjectID!) {
                mergePullRequest(input: {
                  pullRequestId: $prId,
                  mergeMethod: MERGE,
                  expectedHeadOid: $expected
                }) {
                  pullRequest { number merged }
                }
              }
            `, { prId: pr.data.node_id, expected: expectedHead });
